"""music organize <dir> — beets passthrough for tagging and importing."""

import sys
from pathlib import Path
from typing import Optional

import typer

from muzik.config import BEETS_CONFIG
from muzik.core.runner import run_passthrough
from muzik.ui.console import console, err

# Muzik-managed beets config overlay — chained via beet's `include:` so the
# user's own config is fully respected.  The only thing we inject is
# `duplicate_action: skip` so that albums already in the library are silently
# skipped instead of prompting for every re-run.
_MUZIK_OVERLAY = Path.home() / ".config" / "beets" / "muzik_workflow.yaml"


def _beet_bin() -> str:
    """Return the path to the beet binary in the same venv as this Python."""
    beet = Path(sys.executable).parent / "beet"
    return str(beet) if beet.exists() else "beet"


def _write_beets_overlay(user_cfg: Optional[Path]) -> Path:
    """Write (or refresh) the muzik beets overlay and return its path.

    The overlay uses beet's ``include:`` directive to chain the user config,
    then overrides ``import.duplicate_action`` to ``skip``.  This means
    albums already present in the library are automatically skipped on every
    workflow re-run without any interactive prompt.
    """
    _MUZIK_OVERLAY.parent.mkdir(parents=True, exist_ok=True)

    lines = ["# Auto-generated by muzik — safe to delete, will be recreated.\n"]
    if user_cfg and user_cfg.exists():
        # Absolute path; quotes handle spaces in home directories.
        lines.append(f"include:\n- '{user_cfg}'\n\n")
    lines.append("import:\n  duplicate_action: skip\n")

    _MUZIK_OVERLAY.write_text("".join(lines))
    return _MUZIK_OVERLAY


def organize_cmd(
    directory: Path = typer.Argument(..., help="Directory containing audio tracks."),
    import_: bool = typer.Option(
        False,
        "--import",
        "-i",
        help="Import files into beets library (moves files).",
    ),
    tag_only: bool = typer.Option(
        False,
        "--tag-only",
        "-t",
        help="Only write tags; do not move or import files.",
    ),
    dry_run: bool = typer.Option(
        False,
        "--dry-run",
        "-d",
        help="Show what beets would do without making changes.",
    ),
    config: Optional[Path] = typer.Option(
        None,
        "--config",
        "-c",
        help=f"Beets config file (default: {BEETS_CONFIG}).",
    ),
) -> None:
    """Organize/tag audio files using beets.

    Passes stdin/stdout directly to beet so interactive prompts work.
    Albums already present in the beets library are skipped automatically
    (no prompt) via a muzik-managed config overlay.
    """
    beets_cfg = config or BEETS_CONFIG

    if not directory.exists():
        err(f"[red]Directory not found: {directory}[/red]")
        raise typer.Exit(1)

    if not beets_cfg.exists():
        err(
            f"[yellow]Beets config not found at {beets_cfg}.[/yellow] "
            "Run [bold]beet config[/bold] to create one."
        )
        # Don't abort — beet itself will handle the missing config

    # Build beet command — use venv-local binary so it works under `uv run`
    cmd = [_beet_bin()]

    if tag_only:
        # tag_only doesn't benefit from the duplicate overlay; use user config directly
        if beets_cfg.exists():
            cmd += ["-c", str(beets_cfg)]
        console.print(f"[bold]beet write[/bold] (tag-only) {directory}")
        cmd += ["write"] + (["--yes"] if not dry_run else []) + [str(directory)]
    else:
        # For import operations, inject the muzik overlay so duplicates are
        # silently skipped.  The overlay chains the user's config via include:.
        overlay = _write_beets_overlay(beets_cfg)
        cmd += ["-c", str(overlay)]
        console.print(f"[bold]beet import[/bold] {directory}")
        subcmd = ["import", "--incremental"]
        if dry_run:
            subcmd.append("--pretend")
        cmd += subcmd + [str(directory)]

    rc = run_passthrough(cmd)
    if rc != 0:
        err(f"[red]beet exited with code {rc}[/red]")
        raise typer.Exit(rc)

    console.print("[green]beet finished.[/green]")
